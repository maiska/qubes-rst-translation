# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, test
# This file is distributed under the same license as the qubes-docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: qubes-docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-16 23:45+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../user/security-in-qubes/u2f-proxy.rst:3
#: b316333423e04b5c94ca3a8cd24ece3a
msgid "U2F proxy"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:6
#: 143ae41470254ae6984177b887c68454
msgid "The `Qubes U2F Proxy <https://github.com/QubesOS/qubes-app-u2f>`__ is a secure proxy intended to make use of U2F two-factor authentication devices with web browsers without exposing the browser to the full USB stack, not unlike the :doc:`USB keyboard and mouse proxies </user/how-to-guides/how-to-use-usb-devices>` implemented in Qubes."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:13
#: 0f071860a2ac4b4bab12757e06f6bd90
msgid "What is U2F?"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:16
#: eafe47309a3543fe8e3baec54c7ca329
msgid "`U2F <https://en.wikipedia.org/wiki/U2F>`__, which stands for “Universal 2nd Factor”, is a framework for authentication using hardware devices (U2F tokens) as “second factors”, i.e. *what you have* as opposed to *what you know*, like a passphrase. This additional control provides `good protection <https://krebsonsecurity.com/2018/07/google-security-keys-neutralized-employee-phishing/>`__ in cases in which the passphrase is stolen (e.g. by phishing or keylogging). While passphrase compromise may not be obvious to the user, a physical device that cannot be duplicated must be stolen to be used outside of the owner’s control. Nonetheless, it is important to note at the outset that U2F cannot guarantee security when the host system is compromised (e.g. a malware-infected operating system under an adversary’s control)."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:29
#: 744720bf65cc4b948ef68cb1fb5655ca
msgid "The U2F specification defines protocols for multiple layers from USB to the browser API, and the whole stack is intended to be used with web applications (most commonly websites) in browsers. In most cases, tokens are USB dongles. The protocol is very simple, allowing the devices to store very little state inside (so the tokens may be reasonably cheap) while simultaneously authenticating a virtually unlimited number of services (so each person needs only one token, not one token per application). The user interface is usually limited to a single LED and a button that is pressed to confirm each transaction, so the devices themselves are also easy to use."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:40
#: 4e75a1f48b6247edbc076737545e4ea5
msgid "Currently, the most common form of two-step authentication consists of a numeric code that the user manually types into a web application. These codes are typically generated by an app on the user’s smartphone or sent via SMS. By now, it is well-known that this form of two-step authentication is vulnerable to phishing and man-in-the-middle attacks due to the fact that the application requesting the two-step authentication code is typically not itself authenticated by the user. (In other words, users can accidentally give their codes to attackers because they do not always know who is really requesting the code.) In the U2F model, by contrast, the browser ensures that the token receives valid information about the web application requesting authentication, so the token knows which application it is authenticating (for details, see `here <https://fidoalliance.org/specs/fido-u2f-v1.2-ps-20170411/fido-u2f-overview-v1.2-ps-20170411.html#site-specific-public-private-key-pairs>`__). Nonetheless, `some attacks are still possible <https://www.wired.com/story/chrome-yubikey-phishing-webusb/>`__ even with U2F (more on this below)."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:58
#: cf04403a04114467846b6dbaf5aee42e
msgid "The Qubes approach to U2F"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:61
#: be167ed8070b40b198a69188f5b824c1
msgid "In a conventional setup, web browsers and the USB stack (to which the U2F token is connected) are all running in the same monolithic OS. Since the U2F model assumes that the browser is trustworthy, any browser in the OS is able to access any key stored on the U2F token. The user has no way to know which keys have been accessed by which browsers for which services. If any of the browsers are compromised, it should be assumed that all of the token’s keys have been compromised. (This problem can be mitigated, however, if the U2F device has a special display to show the user what’s being authenticated.) Moreover, since the USB stack is in the same monolithic OS, the system is vulnerable to attacks like `BadUSB <https://www.blackhat.com/us-14/briefings.html#badusb-on-accessories-that-turn-evil>`__."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:73
#: 6180d4c273a047d5af6ae2a60f34409c
msgid "In Qubes OS, by contrast, it is possible to securely compartmentalise the browser in one qube and the USB stack in another so that they are always kept separate from each other. The Qubes U2F Proxy then allows the token connected to the USB stack in one qube to communicate with the browser in a separate qube. We operate under the assumption that the USB stack is untrusted from the point of view of the browser and also that the browser is not to be trusted blindly by the token. Therefore, the token is never in the same qube as the browser. Our proxy forwards only the data necessary to actually perform the authentication, leaving all unnecessary data out, so it won’t become a vector of attack. This is depicted in the diagram below (click for full size)."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:85
#: 3af21597e50843ca920c9dab6ff23d04
msgid "|Qubes U2F Proxy diagram|"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:0
#: ../../../user/security-in-qubes/u2f-proxy.rst:0
#: b8f54c28b0644f1092931125433feb8e
#: ece734e3fa81464c813828a07bba12fe
msgid "Qubes U2F Proxy diagram"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:87
#: b8461b89d2e6414c81872d5753dfeb60
msgid "The Qubes U2F Proxy has two parts: the frontend and the backend. The frontend runs in the same qube as the browser and presents a fake USB-like HID device using ``uhid``. The backend runs in ``sys-usb`` and behaves like a browser. This is done using the ``u2flib_host`` reference library. All of our code was written in Python. The standard :doc:`qrexec </developer/services/qrexec>` policy is responsible for directing calls to the appropriate domains."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:95
#: f395c62b0d9c4fb9b7eae39d5f2d6be8
msgid "The ``vault`` qube with a dashed line in the bottom portion of the diagram depicts future work in which we plan to implement the Qubes U2F Proxy with a software token in an isolated qube rather than a physical hardware token. This is similar to the manner in which :doc:`Split GPG </user/security-in-qubes/split-gpg>` allows us to emulate the smart card model without physical smart cards."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:101
#: c55123a485924970880e5f5cf859e3b9
msgid "One very important assumption of U2F is that the browser verifies every request sent to the U2F token — in particular, that the web application sending an authentication request matches the application that would be authenticated by answering that request (in order to prevent, e.g., a phishing site from sending an authentication request for your bank’s site). With the WebUSB feature in Chrome, however, a malicious website can `bypass <https://www.wired.com/story/chrome-yubikey-phishing-webusb/>`__ this safeguard by connecting directly to the token instead of using the browser’s U2F API."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:112
#: 17c1714bb48d42d8a2ef0e9832eabe2c
msgid "The Qubes U2F Proxy also prevents this class of attacks by implementing an additional verification layer. This verification layer allows you to enforce, for example, that the web browser in your ``twitter`` qube can only access the U2F key associated with ``https://twitter.com``. This means that if anything in your ``twitter`` qube were compromised — the browser or even the OS itself — it would still not be able to access the U2F keys on your token for any other websites or services, like your email and bank accounts. This is another significant security advantage over monolithic systems. (For details and instructions, see the `Advanced usage <#advanced-usage-per-qube-key-access>`__ section below.)"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:123
#: 0965e1ef7e02450589c205fa6055a43d
msgid "For even more protection, you can combine this with the :doc:`Qubes firewall </user/security-in-qubes/firewall>` to ensure, for example, that the browser in your ``banking`` qube accesses only one website (your bank’s website). By configuring the Qubes firewall to prevent your ``banking`` qube from accessing any other websites, you reduce the risk of another website compromising the browser in an attempt to bypass U2F authentication."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:130
#: 5dd7a8e3f5d64828ae40de5dca7a73dc
msgid "Installation"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:133
#: 4deb4c44b77b4393baa031b97782a1c0
msgid "These instructions assume that there is a ``sys-usb`` qube that holds the USB stack, which is the default configuration in most Qubes OS installations."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:137
#: d6a982194c6845fe9b2818b11fc08cbd
msgid "In dom0:"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:146
#: 63519e51df08409ba7409b082507744e
msgid "The above assumes a ``work`` qube in which you would like to enable u2f. Repeat the ``qvm-service`` command for all qubes that should have the proxy enabled. Alternatively, you can add ``qubes-u2f-proxy`` in VM settings -> Services in the Qube Manager of each qube you would like to enable the service."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:152
#: 60b9bed0a74b44329c24f01c8463a065
msgid "In Fedora templates:"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:160
#: 6dea306b98da40cbae48e9ad719efba3
msgid "In Debian templates:"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:168
#: 217f3dc86f6b49a48a70b10c9d6af599
msgid "As usual with software updates, shut down the templates after installation, then restart ``sys-usb`` and all qubes that use the proxy. After that, you may use your U2F token (but see `Browser support <#template-and-browser-support>`__ below)."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:173
#: 29fa5de7f15945a3807051ab08dbdc86
msgid "Advanced usage: per-qube key access"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:176
#: b9ec308f24c74691b29e8130204df6d9
msgid "If you are using Qubes 4.0, you can further compartmentalise your U2F keys by restricting each qube’s access to specific keys. For example, you could make it so that your ``twitter`` qube (and, therefore, all web browsers in your ``twitter`` qube) can access only the key on your U2F token for ``https://twitter.com``, regardless of whether any of the web browsers in your ``twitter`` qube or the ``twitter`` qube itself are compromised. If your ``twitter`` qube makes an authentication request for your bank website, it will be denied at the Qubes policy level."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:185
#: 8680974d870b4ba59273de19e2257734
msgid "To enable this, create a file in dom0 named ``/etc/qubes-rpc/policy/policy.RegisterArgument+u2f.Authenticate`` with the following content:"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:195
#: 51ecab243e154f0f8462ed5ca576bd57
msgid "Next, empty the contents of ``/etc/qubes-rpc/policy/u2f.Authenticate`` so that it is a blank file. Do not delete the file itself. (If you do, the default file will be recreated the next time you update, so it will no longer be empty.) Finally, follow your web application’s instructions to enroll your token and use it as usual. (This enrollment process depends on the web application and is in no way specific to Qubes U2F.)"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:202
#: 6e1bcac9d88b4255b233a4d36332b503
msgid "The default model is to allow a qube to access all and only the keys that were enrolled by that qube. For example, if your ``banking`` qube enrolls your banking key, and your ``twitter`` qube enrolls your Twitter key, then your ``banking`` qube will have access to your banking key but not your Twitter key, and your ``twitter`` qube will have access to your Twitter key but not your banking key."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:210
#: 23ed6bedace94530aa9c0d59726dd34c
msgid "Non-default USB qube name"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:213
#: 5e2b2232ea0645e69fe8a8e41ebd4e72
msgid "If your USB qube is named differently than ``sys-usb``, then do the following in the appropriate template(s):"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:223
#: 20d9149d774649129a13edab825d2e24
msgid "Replace ``USB_QUBE`` with the actual USB qube name."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:225
#: 1e6cf35c036d4179958f3bdd2c6c2e6a
msgid "Do not forget to change the sys-usb qube name in the policy ``/etc/qubes-rpc/policy/u2f.Authenticate``."
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:229
#: 18c1dd2bc9864f7f8eb8dea3c6148b34
msgid "Template and browser support"
msgstr ""

#: ../../../user/security-in-qubes/u2f-proxy.rst:232
#: 8c382069e184495f9ec0d5aec8710158
msgid "The large number of possible combinations of template (Fedora 27, 28; Debian 8, 9) and browser (multiple Google Chrome versions, multiple Chromium versions, multiple Firefox versions) made it impractical for us to test every combination that users are likely to attempt with the Qubes U2F Proxy. In some cases, you may be the first person to try a particular combination. Consequently (and as with any new feature), users will inevitably encounter bugs. We ask for your patience and understanding in this regard. As always, please :doc:`report any bugs you encounter </introduction/issue-tracking>`."
msgstr ""
